问题
1. 讲一讲堆和栈
2. 进程和线程
3. 锁

解答
1. 
一个进程启动时系统会单独分配一块内存区域给该进程，除了文字常量区（即常量字符串如 "string"），程序代码区，及全局静态区（全局变量），就是栈区和堆区，
栈是从高地址往下增长，堆为低地址往上。栈为线程独有的，即一个进程如果有多个线程，那每个线程都有自己的独有栈。

存储内容：
栈 -- 存储各种局部变量，方法的参数，及方法的返回地址。 栈由系统自动分配，如果超过内存大小则报栈溢出，如递归不停止
e.g. 方法A调用方法B，栈的地址会向下增长，保存方法A的局部变量，参数，返回地址，然后进入到方法B内，方法B执行
完后重新根据返回地址回到方法A
堆 -- 一般由程序员申请，如malloc(10), 或 new Obj()。 
e.g. Obj a = new Obj(), 对象的引用 a 是存在栈区，而new的这个对象存在堆区

存储大小：
栈 -- 1-4M之间，小
堆 -- 2G左右，和虚拟内存有关，大

访问速度：
栈 -- 是连续的，编译时分配空间，直接寻址，速度快，但由系统自动分配，程序员无法控制
堆 -- 是不连续的，空闲地址由一个链表的形式存储，运行时分配空间，间接寻址，速度慢，容易产生内存碎片

2.
进程是程序的一次活动，可以理解为我们写的一段代码他是一个程序，当run以后就启动了该程序的进程，一个进程可以拥有多个线程。
进程和线程是CPU执行的最小任务单元。
进程大于线程，每个进程系统会单独分配一块地址空间，而同一个进程的线程之间除了自己的局部变量存在自己的栈里，其他内容都是共享的。
进程之间切换开销大，线程开销小。

3.
竞争条件 -- 一块临界资源是共享的，一段相同的程序代码执行多次，临界资源的结果却出现多种情况（因为线程和进程并行时执行的顺序可能不一样）
死锁 -- 为了解决race condition，加入了锁，就是临界资源在访问时一次只能有一个进程可以读/写该资源，即对该资源加锁，而这有可能出现多个进程互相请求对方的临界资源而又自己抓着对方需要的临界资源
不放，导致进程block
活锁 -- 都是任务无法执行，活锁可以用两个人走路互相让路却始终无法继续往下走来解释
饥饿 -- 抢占式的CPU调度会引起这种情况，即进程有优先级，导致优先级低的进程一直处于等待状态被优先级高的进程抢在前面
饥饿的解决办法 -- aging，老化，即当等待的进程每等待若干次后该进程的优先级就会提高一级，以防止他永远不会被CPU执行的问题
